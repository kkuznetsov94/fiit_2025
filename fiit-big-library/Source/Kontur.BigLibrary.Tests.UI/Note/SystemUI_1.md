## Системные UI тесты. 1 занятие
### Выбор инструментов для тестов

При выборе инструмента для тестов опирайтесь на следующие факторы:

1) Язык на котором будут писаться тесты.

Что бы выбрать язык, подумайте о том, кто будет писать тесты: бэкенд или фронтенд разработчики. Исходя из этого, выберите более привычный язык.

2) Нужна кросбраузерность

Планируете ли вы запускать АТ в разных браузерах? 

3) Параллельность

Планируете ли вы запускать тесты праллельно. Например, для небольшого проекта, который не планируется активно дорабатывать, параллельность может быть и не нужна

4) Операционная система

5) Платный или бесплатный инструмент

**Selenium** -- это набор инструментов для браузерного автоматизированного тестирования.

**Selenium WebDriver** -- это инструмент для автоматизации действий веб-браузера

## Для написания UI тестов нам необходима инфраструктура:
- Установленный браузер (Chrome).
- Chromedriver - вспомогательный исполняемый файл, который помогает совершать действия над браузером из кода.
- Библиотека Selenium для C#.

## Поиск элементов
Для поиска элементов используем метод FindElement().
В него передается локатор элемента. Локаторы используются разные:
- By.Id - по атрибуту id.
- By.TagName - по имени тега.
- By.ClassName - по имени класса.
- By.Name - по атрибуту name.
- By.LinkText - по тексту ссылки.
- By.PartialLinkText - по частичному тексту ссылки (очень медленно).
- By.CssSelector - сложный локатор.
- By.XPath - сложный локатор.

Поиск с помощью **CSS** - поиск элемента от родительского к дочернему.

### Стратегии поиска по CSS-локаторам:
- div#maxwidth - элемент с тегом div и с атрибутом id=”maxwidth”. Id в CSS-селекторах обозначается решеткой. В консоли это будет выглядеть так - $$(“div#maxwidth”).
- div.b-cdm-e-arrow - элемент с тегом div и с атрибутом class=”b-cdm-e-arrow”. Класс в CSS-селекторах обозначается точкой.
- form[name] - ищет элемент с тегом form и атрибутом name. form[name=’searchform’] - ищет элемент с тегом form и атрибутом name=”searchform”.
- form[name*=’search’] - ищет элемент с тегом form и атрибутом name, в значении которого присутствует search.
- form[name^=’search’] - ищет элемент с тегом form и атрибутом name, значение которого начинается с search.
- form[name$=’fixed’] - ищет элемент с тегом form и атрибутом name, значение которого заканчивается словом fixed.
- option:not([selected]) - ищет элемент с тегом option и отсутствием атрибута selected.
- div > form - ищет элемент form, который находится непосредственно внутри элемента div.
- div form - ищет элемент form на любом уровне внутри элемента div.
- ul li:first-child - ищет элемент, который удовлетворяет сразу трем условиям:
  - является дочерним любого уровня у ul.
  - является первым ребенком своего родителя.
  - является тегом li.
Таким образом, если первый ребенок - тег \<a\>, то элемент по этому локатору не найдется.
- ul li:last-child - ищет элемент, который удовлетворяет сразу трем условиям:
  - является дочерним любого уровня у ul.
  - является последним ребенком своего родителя.
  - является тегом li.
Таким образом, если последний ребенок - тег \<a\>, то элемент по этому локатору не найдется.
- ul li:nth-child(5) -  ищет элемент, который удовлетворяет сразу трем условиям:
  - является дочерним любого уровня у ul
  - является пятым ребенком своего родителя
  - является тегом li.
Таким образом, если пятый ребенок - тег \<a\>, то элемент по этому локатору не найдется.
- nth-child - поиск начинается с 1, а не с 0 как обычно.
- div.ui-widget div:nth-of-type(2) - ищет второй элемент div в элементе div.ui-widget.
Обратите внимание, что нумерация поиска элемента с помощью nth-of-type - поиск начинается с 1, а не с 0 как обычно.

Поиск по **Xpath** - похож на CSS, но с его помощью можно искать не только вглубь, но и вверх.

### Стратегии поиска по Xpath-локатору:
- //*[@class=‘email’] - // - любой родитель, * - любой элемент с любым тегом.
То есть ищем в любом месте любой элемент, у которого class=email. В консоли - $x(“//*[@class=’email’]”). Без * или без // - локатор будет неверный, про что вам просигнализирует консоль.
Таким образом, если мы будем искать элемент у которого классы class=”email footer-email-icon” и для этого будем использовать локатор  $x(“//*[@class=’email’]”), то элемент у нас не найдется, потому-что в локаторе указан один класс, а у элемента в атрибуте class их два, а мы искали по ТОЧНОМУ соответствию.
Для того, чтобы искать по одному классу из атрибута, лучше использовать contains (о нем ниже). Он позволит искать по условию “атрибут содержит”.
- //*[contains(@name, ‘email’)] - значение атрибута name содержит значение email, необязательно равно.
- //input[@id=’email’]/../input[@type=’button’] - две точки означают переход к родительскому элементу. То есть сначала нашли элемент input[@id=’email’], потом его родителя, потом в нем input[@type=’button’].
- //ul/li[2] - в элементе ul найти 2-ой элемент li.
- //tagName[text()=’Текст’] - поиск по тексту, не обязательно по тексту ссылки.
- (//tagName[@id=’IdName’])[1] - вернет первый элемент. В квадратных скобках указываем какой по счету элемент нам нужен с таким локатором.

### Домашнее задание
Найти элементы в Библиотеке с помощью CSS и/или XPath. Результат оформить в отдельном методе в виде кода:

`var someButton = driver.FindElement(By.CssSelector("button#someButton"));
var anotherButton = driver.FindElement(By.XPath("//button[@id=’someButton’]"));`

Элементы для поиска:
1. Строка поиска ![img.png](img.png)
2. Вторую свободную книгу на списке ![img_1.png](img_1.png)
3. На странице книги кнопки “Взять книгу” и ссылка “Все книги” ![img_2.png](img_2.png)
4. Тогл "Только свободные" на списке книг ![img_3.png](img_3.png)
5. Поля, кнопки, заголовок при добавлении книги:
   - Заголовок “Добавить книгу”
   - Кнопка “Добавить”
   - Поле “Название книги” ![img_4.png](img_4.png)


