## Авторизация в сервисе
Если в каждом тесте проходить этап авторизации через UI, то

1. Тест на проверку одной части функциональности начинает зависеть от функциональности, которую этот тест не проверяет. 
Например, если у нас сломается страница регистрации, то тесты на вход в систему тоже начнут падать.

2. Длительность теста увеличивается в разы. Тест взаимодействует со множеством компонентов на UI, 
хотя эти действия непосредственно не направлены на проверу, реализуемую тестом.

Для авторизациии используем **AuthHelper.CreateUserAndGetTokenAsync**.

Подобные хелперы выделяются не только для авторизации, но и для любой подготовки перед тестами, например создание книги.
Т.е. вся подготовка данных в UI тестах выполняется не через сам UI, 
а с помощью вызовов сервисов напрямую, либо через API, подобно тому как это делается в интеграционных тестах.

Важно, что это относится только к тем данным, которые предполагаются пользовательским сценарием теста.

Если необходимо проверить сценарий того, что нельзя взять занятую книгу, то можно создать занятую книгу через хелпер.
Если необходимо проверить, что книга становится занятой -- то создать свободную книгу можно через хелпер, а производить действия для взятия книги -- через UI.

Все вспомогательные методы, должны быть быстрыми и стабильными 

Для того, чтоб не заполнять поля на странице авторизации в каждом тесте, нужно передать данные об авторизации в браузер.
Обычно, это можно сделать добавив cookies с авторизациолнными данными. Для этого можно использовать метод `WebDriver.Manage().Cookies.AddCookie()`
В случае, когда данные об авторизации хранятся в LocalStorage браузера, можно использовать метод `ExecuteJavaScript()`.
Он позволяет выполнить любой JavaScript в браузере, может быть полезен для различных действий на тестируемой странице.

## Работа с артефактами

Артефакты браузера можно использовать, для ускорения и упрощения понимания причин падения тестов. 
В качестве артефактов используются **скриншоты** и **логи**.

Для того чтобы получить скриншот страницы в момент падения тестов, используем метод GetScreenshot() для WebDriver.
Для того, чтоб не делать скриншот для каждого теста, можно получить статус прохождения теста, используя метод NUnit `TestContext.CurrentContext.Result.Outcome`.

Скриншоты помогут в разборе падений, только если они связаны с визуальным отображением. 
Если сбой связан со внутренней ошибкой, увидеть ее можно по логам браузера. 

Получить логи браузера можно используя метод `WebDriver.Manage().Logs.GetLog()`.
А задать уровень логирования можно используя метод `ChromeOptions.SetLoggingPreference()`

Для получения логов во время работы теста, используем `NetworkManager`
Метод `SetNetworkManager` В `UiTestBase` принимает в себя контекст браузера и позволяет написать обработчики на разные сетевые события.
Например, можно логировать все сетевые запросы, код которых >300. т.е. все неуспешные события и записывать их в логи.

## Домашнее задание
Написать тесты, с использованием PageObject и PageElement паттернов, для сценариев:

1. Первый пользователь создает через UI системы книгу, второй пользователь может увидеть ее и все данные о книге.
Для авторизации под разными пользователями необходимо добавить метод выхода из системы. Реализуйте его через взаимодействие с jwtTokenом в localStorage браузера, по аналогии с методом авторизации.

Для выбора рубрик в UI используйте JS, например скрипт "document.querySelector("#bookRubricId").value = X", где X значение value для элемента выпадающего списка.

2. Напишите тест, добавляющий в браузер сookie с именем "TestData", значением равным текущей дате и сроком жизни 1 час.